package net.frakbot.google.challenge.breedinglikerabbits;

import java.math.BigInteger;
import java.util.HashMap;

/**
 * @author Francesco Pontillo
 */
public class Answer {
    public static final String NONE = "None";
    public static final HashMap<BigInteger, Double> partials = new HashMap<BigInteger, Double>();

    private final static BigInteger TWO = BigInteger.valueOf(2);
    private final static BigInteger THREE = BigInteger.valueOf(3);

    // seed values
    static {
        partials.put(BigInteger.ZERO, 1D);
        partials.put(BigInteger.ONE, 1D);
        partials.put(TWO, 2D);
    }

    public static String answer(String str_S) {
        Double zombits;
        try {
            zombits = Double.parseDouble(str_S);
        } catch (Exception e) {
            return NONE;
        }

        // search for the result in both search spaces (odd and even)
        BigInteger oddTime = getTimeExponential(zombits, false);
        BigInteger evenTime = getTimeExponential(zombits, true);
        BigInteger time = oddTime.max(evenTime);

        if (time.compareTo(BigInteger.ZERO) < 0) {
            return NONE;
        }
        return String.format("%s", time);
    }

    /**
     * Makes an iterative exponential search to split the search space (that is expensively generated).
     *
     * @param number The number to search in the space.
     * @param even   {@code true} if the number must be searched in the space generated by even indexes only,
     *               {@code false} if the number must be searched in the space generated by odd indexes only.
     * @return       A {@link BigInteger} representing the value x for which R(x) = number.
     */
    private static BigInteger getTimeExponential(Double number, boolean even) {
        if (number < 3) {
            return number == 0 ? BigInteger.ONE : BigInteger.valueOf(number.longValue());
        }
        BigInteger base = TWO;
        BigInteger min = even ? BigInteger.ZERO : BigInteger.ONE;
        int exp = 1;
        boolean changed = true;
        do {
            // calculate the starting index
            // the initial start is 2 + min so it's always compatible to even/odd
            // following restarts begin at 2 + min so the even/odd property is kept
            BigInteger index = base.pow(exp).add(min);
            // calculate the value at current index
            Double value = R(index);
            // if the value at the beginning of the current index equals the one we're looking for, return the index
            if (value.equals(number)) {
                return index;
            }
            // if we passed the number we're searching for at the current index, reset the exponent and restart from a new value
            if (value.compareTo(number) > 0) {
                // the new min will use the previous exponent and will be increased by the current min so we look for next items only
                min = base.pow(exp - 1).add(min);
                // if this is the first loop AGAIN, exit, since we're in a range that can't be simplified anymore
                if (exp == 1) {
                    changed = false;
                }
                exp = 1;
            } else {
                // increment the exponent so we search faster
                exp += 1;
            }

        } while (changed);
        // at this point the min value is the only candidate index whose R value can be equal to the number
        Double value = R(min);
        if (number.equals(value)) {
            return min;
        }
        return BigInteger.valueOf(-1);
    }

    /**
     * Recursive method to generate the search space for a given value of time.
     * @param time  The value to generate the result of R(time) for.
     * @return      The result of R(time) according to the specs.
     */
    public static Double R(BigInteger time) {
        if (partials.get(time) == null) {
            Double value;
            if (isEven(time)) {
                value = R(time.divide(TWO)) + R(time.divide(TWO).add(BigInteger.ONE)) + time.divide(TWO).doubleValue();
            } else {
                value = R(time.subtract(THREE).divide(TWO)) + R(time.subtract(BigInteger.ONE).divide(TWO)) + 1;
            }
            partials.put(time, value);
        }
        return partials.get(time);
    }

    private static boolean isEven(BigInteger value) {
        return value.mod(TWO).equals(BigInteger.ZERO);
    }

    /*

    private static final int MAX_POINTS = 100;

    long[] oddX = new long[MAX_POINTS];
    long[] evenX = new long[MAX_POINTS];
    double[] oddY = new double[MAX_POINTS];
    double[] evenY = new double[MAX_POINTS];

    // build the first n = MAX_POINTS*2 values (avoid 0, 1, 2 as they may bias the approximation)
    for (int i = 3; i < (MAX_POINTS * 2) + 3; i++) {
        if (i % 2 == 1) {
            oddX[(i-3)/2] = i;
            oddY[(i-3)/2] = getValue(i);
        } else {
            evenX[(i-4)/2] = i;
            evenY[(i-3)/2] = getValue(i);
        }
    }

    double[][] coefficients = getCoefficients(oddX, oddY, evenX, evenY);
    double[] oddDifferences = coefficients[0];
    double[] evenDifferences = coefficients[1];

    // use Neville's differences algorithm to find the polynomials coefficients
    // (see https://en.wikipedia.org/wiki/Neville%27s_algorithm)
    private static double[][] getCoefficients(long[] oddX, double[] oddY, long[] evenX, double[] evenY) {
        double[] oddDifferences = oddY.clone();
        double[] evenDifferences = evenY.clone();
        for (int col = 1; col < MAX_POINTS; col++) {
            // for each loop, calculate all the differences
            for (int row = MAX_POINTS - 1; row > 0; row--) {
                if(row >= col) {
                    oddDifferences[row] = (oddDifferences[row] - oddDifferences[row - 1]) / (oddX[row] - oddX[row - col]);
                    evenDifferences[row] = (evenDifferences[row] - evenDifferences[row - 1]) / (evenX[row] - evenX[row - col]);
                }
            }
        }
        return new double[][] {oddDifferences, evenDifferences};
    }

    public static Double getSolutionForTime(long time, long[] x, double[] coefficients) {
        double solution = 0D;
        for (int i = 0; i < MAX_POINTS; i++) {
            Double term = coefficients[i];
            for (int j = 0; j < i; j++) {
                if (term == 0) {
                    break;
                }
                term *= (time - x[j]);
            }
            solution += term;
        }
        return solution;
    }

    private static BigInteger getTimeBisection(Double number, BigInteger min, BigInteger max) {
        BigInteger medium = max.subtract(min).divide(TWO).add(min);
        Double mediumValue = R(medium);
        if (mediumValue.equals(number)) {
            return medium;
        }
        if (number < mediumValue) {
            return getTimeBisection(number, min, medium);
        }
        return getTimeBisection(number, medium, max);
    }

    private static BigInteger getTimeLinear(Double number, BigInteger min, BigInteger max) {
        // while min <= max, calculate min and check for number, then increment it
        for (; min.compareTo(max) <= 0; min = min.add(TWO)) {
            Double value = R(min);
            // if the number equals the current value at min, return min
            if (number.equals(value)) {
                return min;
            }
        }
        return BigInteger.valueOf(-1);
    }

    */

}
